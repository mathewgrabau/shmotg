<!DOCTYPE HTML>
<html>
  <head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0,maximum-scale=1.0, user-scaleable=no" />
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="description" content="bwim" />

  <title>Manitoba BWIM Event Viewer</title>
  <link href="http://cdn.syncfusion.com/js/web/flat-azure/ej.web.all-latest.min.css" rel="stylesheet" />
  
  <style type="text/css">
    #chart-options {
      border: 1px solid black;
    };
  </style>
  
  
  <script type="text/javascript" src="socket.io-1.1.0.js"></script>
  <script type="text/javascript" src="http://code.jquery.com/jquery-1.10.1.min.js"></script>
  <script src="http://cdnjs.cloudflare.com/ajax/libs/jquery-easing/1.3/jquery.easing.min.js"></script>
  <script src="http://ajax.aspnetcdn.com/ajax/globalize/0.1.1/globalize.min.js"></script>
  <script type="text/javascript" src="http://borismoore.github.io/jsrender/jsrender.min.js"></script>
  <script type="text/javascript" src="http://cdn.syncfusion.com/js/ej.widgets.all-latest.min.js"></script>
  <script type="text/javascript" src="underscore.js"></script>
  
  
  </head>
  <body>
  

  <!-- AppView declaration -->
  <div data-role="app$iew">Mobile JS Application
    <div><select id="year">
        <option value="2014">2014</option>
      </select>
      <select id="month">
        <option value="6">06 (JUN)</option>
        <option value="7">07 (JUL)</option>
        <option value="8">08 (AUG)</option>
        <option selected value="9">09 (SEP)</option>
      </select>
    </div>
    <div id="mobgrid" style="width: 100%;"></div>
  </div>



  <!-- this should be moved to a separate script file -->
  <script type="text/javascript">
    $(function() {
        // TODO maybe move the configuration to another object/definition.
        var socket = io.connect("misc.mathewgrabau.ca:8888/");
        var firstTime = true;

        // This is the one getting bound to my events of the data now.
        var bridgeEvents = [];

        var requestId = 0;
        
        function nextRequestId() {
          return (requestId++);
        }

        socket.on("news", function(data) {
            if (!firstTime) {
              return;
            }

            firstTime = false;

            // Initialize the grid now, start getting the data better
            var dataRequest = {
              sensorType: "bwimEvents",
              date: 20140901,
              id: nextRequestId()
            };

            socket.emit("req", JSON.stringify(dataRequest));

        });

        $("#month").change(function() {
            // TODO we need to get the values for the day in there as well.
            var month = parseInt($(this).val());

            // Then the parsing of the requested values must be sent out.
            var d = parseInt($("#year").val()) * 10000 + parseInt($("#month").val()) * 100 + 01;

            //console.log(d);

            var request = {
              sensorType: "bwimEvents",
              date: d,
              id: nextRequestId()
            };

            // Send the request to the proper values.
            socket.emit("req", JSON.stringify(request));
        });

        var dataManager = null;
        var receivedData = [];

        var firstEventSelection = true;

        //var currrentEventData = null;
        window.currentEventData = null;

        socket.on("section_data", function(data) {

            // Get the data back from the parsing of the values that are attempting to be created.
            var received = JSON.parse(data);

            currentEventData = received;

            // Determine if the values exists yet.
            if (firstEventSelection) {
              firstEventSelection = false;

              $(".appview").append("<div id='section-selector'></div>");
              $("#appview").append("<div id='section-selector'></div>");
              $("#section-selector").append("<input type='button' id='show-aa' value='AA' />");
              $("#section-selector").append("<input type='button' id='show-cc' value='CC' />");
              $("#section-selector").append("<input type='button' id='show-dd' value='DD' />");
            }
            
            // Create the tabs that will be used there.
            $("#show-aa").ejButton({
              click: sectionGroupTouchEnd
            });
            $("#show-cc").ejButton({
              click: sectionGroupTouchEnd
            });
            $("#show-dd").ejButton({
              click: sectionGroupTouchEnd
            });
        });

        function sectionGroupTouchEnd(args) {
          var sectionText = args.model.text;
          updateSectionChart(sectionText);
        }

        // The response for the server posting the event data back.
        socket.on("req_data", function(data) {
            var received = JSON.parse(data);

            // TODO implement the requesting queue already, so in otherwords add ot the data manager.

            // TODO we need to customize these implementations soon, allowing
            if (dataManager == null) {

              receivedData = received.events;
              dataManager = ej.DataManager(receivedData);

              // There are too many items (it only seems to show 14 of them)
              $("#mobgrid").ejGrid({
                  dataSource: dataManager,
                  allowSelection: true,
                  allowColumnSelector: true,
                  allowPaging: true,
                  allowScrolling: true,
                  //scrollSettings: {enableColumnScrolling: true}, 
                  width: 1000,
                  actionComplete: gridActionComplete,

                  rowSelected: gridRowSelected,
                  columns: [
                    { field: "StartTime_DD", width: 200, headerText: "S/DD"},
                    { field: "EndTime_DD", width: 200 , headerText: "E/DD"},
                    { field: "StartTime_CC", width: 200, headerText: "S/CC" },
                    { field: "EndTime_CC", width: 200, headerText: "E/CC" },
                    { field: "StartTime_AA", width: 200, headerText: "S/AA" },
                    { field: "EndTime_AA", width: 200, headerText: "E/AA" }
                    ]
                    });
            } else {

              console.log(dataManager);


              // Apparently this is the most efficient way to do this.
              while (receivedData.length) {
                receivedData.pop();
              }


              // NOTE: I may need a specific value to insert properly.
              received.events.forEach(function(element, index) {
                  dataManager.insert(element);
                  });


              var grid = $("#mobgrid").data("ejmGrid");
              grid.refreshContent();
            }
      });

        // This is just checking for a first (loaded) event.
        var gridFirstEvent = true;

        function gridActionComplete() {
          console.log("gridActionComplete");
          console.log(arguments);

          if (gridFirstEvent) {
          }
        }
            

        function gridRowSelected(e) {
          console.log(e);

          // Then we need to make sure that things are working out well for the appication
          // by closing/hiding the grid, and showing the rendering.
          // We need to emit a socket request, that will get the values of the sectional data.

          // Get the year and properly format that date.


          var MILLISECONDS_SIZE = 1000;
          var SECONDS_SIZE = 100;
          var SECONDS_SHIFT = MILLISECONDS_SIZE;
          var MINUTES_SIZE = 100;
          var MINUTES_SHIFT = SECONDS_SHIFT * SECONDS_SIZE;
          var HOURS_SHIFT = MINUTES_SHIFT * MINUTES_SIZE;
          var HOURS_SIZE = 100;
          var DAY_SHIFT = HOURS_SIZE * HOURS_SHIFT;
          var DAY_SIZE = 100;
          var MONTH_SHIFT = DAY_SHIFT * DAY_SIZE;
          var MONTH_SIZE = 100;
          var YEAR_SHIFT = MONTH_SHIFT * MONTH_SIZE;
          
          
          // Create the proper date now
          var year = parseInt($("#year").val()) * YEAR_SHIFT;

          var addYear = function(x) {
            return year + x;
          }

          var eventRequest = {
            id: requestId,
            sensorType: "eventdata",
            StartTime_AA: addYear(e.data.StartTime_AA),
            EndTime_AA: addYear(e.data.EndTime_AA),
            StartTime_CC: addYear(e.data.StartTime_CC),
            EndTime_CC: addYear(e.data.EndTime_CC),
            StartTime_DD: addYear(e.data.StartTime_DD),
            EndTime_DD: addYear(e.data.EndTime_DD)
          };

          socket.emit("req", JSON.stringify(eventRequest));

        }

        var chartReady = false;
        
        function ensureChartReady() {
          if (!chartReady) {
            $(".appview").append("<div id='chart-container'></div>");
            
            $("<div id='chart-options'></div>").insertBefore("#chart-container");
            
            chartReady = true;
          }
        }
        
        // Prepare the data for the source events.
        // @param girders the names of the griders (to determine a sum)
        // @return Value of the implementations for the description.
        function prepareSeriesSource(girders) {
          var dataGaps = false;
          var lastTimestamp = null;
        
          _.each(currentChartSource, function(element) {
            element.d = new Date(element.ms);
            var currentTimestamp = element.d;
            
            // Take a sum of each of the elements (seeing it across the entire bridge).
            element.sum = 0;
            
            // Sum at the current timestamp
            _.each(girders, function(girder) {
              element.sum += element[girder];
            });
            
            if (lastTimestamp != null) {
              if ((currentTimestamp.getTime() - lastTimestamp.getTime()) > 5) {
                dataGaps = true;
              }
            }
            lastTimestamp = currentTimestamp;
          });
          
          return dataGaps;
        }
        
        var zoomingOptions = {
          enable: true,
          enableMouseWheel: true
        };
        
        var chartRendered = false;

        function updateSectionChart(section) {
          switch (section) {
            case "AA":
              if (currentEventData.aa !== undefined) {
                ensureChartReady();
                
                currentChartSource = currentEventData.aa;

                var girders = ["G25", "G26", "G27", "G28", "G29", "G30", "G31", "G32", "G33", "G34", "G35", "G36", "G37", "G38", "G39", "G40", "G41", "G42", "G43", "G44", "G45", "G46", "G47", "G48"];
                
                // TODO needs the recognition of whether or not there are data gaps in the loaded section/set.
                prepareSeriesSource(girders);
                
                var seriesObjects = _.map(girders, function(girder) {
                  return {
                    type: "line",
                    xName: "d",
                    yName: girder,
                    dataSource: currentChartSource,
                    name: girder
                  };
                });
                
                seriesObjects.push({
                  type: "line",
                  xName: "d",
                  yName: "sum",
                  dataSource: currentChartSource,
                  name: "Sum"
                });
                
                if (chartRendered) {
                  var chartObject = $("#chart-container").data("ejChart");
                  chartObject.model.series = seriesObjects;
                  chartObject.redraw();
                }
                
              }
              break;

            case "CC":
              if (currentEventData.cc !== undefined) {
                ensureChartReady();
                
                currentChartSource = currentEventData.cc;
                
                var girders = ["G9", "G10", "G11", "G12", "G13", "G14", "G15", "G16", "G17", "G18", "G19", "G20", "G21", "G22", "G23", "G24"];
                
                prepareSeriesSource(girders);
                
                // Sum the section data now. 
                var seriesObjects = _.map(girders, function(girder) {
                  return {
                    type: "line",
                    xName: "d",
                    yName: girder,
                    dataSource: currentChartSource,
                    name: girder
                  };
                });
                
                seriesObjects.push({
                  type: "line",
                  xName: "d",
                  yName: "sum",
                  dataSource: currentChartSource,
                  name: "Sum"
                });
                
                if (chartRendered) {
                  // Convert the reference to contain the new series, then just redraw it with the current objects.
                  if (!window.chartObject) {
                    window.chartObject = $("#chart-container").data("ejChart");
                  }
                  window.chartObject.model.series = seriesObjects;
                  window.chartObject.redraw();
                }
                
              } // if (currentEventData.cc !== undefined)
              break;

            case "DD":

              if (currentEventData.dd !== undefined) {
                ensureChartReady();

                // TODO update the chart method here (should support something better for naming the series here.)
                currentChartSource = currentEventData.dd;
                
                var girders = ["G1", "G2", "G3", "G4", "G5", "G6", "G7", "G8"];
                
                var dataGaps = prepareSeriesSource(girders);
                
                if (dataGaps) {
                  alert("Selected data has time gaps");
                } else {
                  console.log("Data is good for the time gaps.");
                }
                
                var seriesObjects = _.map(girders, function(girder) {
                  return {
                    type: "line",
                    xName: "d",
                    yName: girder,
                    dataSource: currentChartSource,
                    name: girder
                  };
                });
                
                seriesObjects.push({
                  type: "line",
                  xName: "d",
                  yName: "sum",
                  dataSource: currentChartSource,
                  name: "Sum"
                });
                
                if (!chartRendered) {
                  $("#chart-container").ejChart({
                    commonSeriesOptions: {
                      tooltip: {visible: true}
                    },
                    zooming: zoomingOptions,
                    // Implementing all 8 at once.
                    series: seriesObjects,
                    primaryXAxis: {
                      title: { text: "ms" },
                      valueType: 'datetime',
                      intervalType: 'Milliseconds'
                    },
                    primaryYAxis: {
                      title: { text: "ustrain" }
                    },
                    crosshair: {
                      visible: true,
                      type: 'trackball',
                      marker: {
                        shape: 'circle',
                        size: {
                          height: 9, width: 9
                        },
                        visible: true
                      }
                    }
                  });
                  
                  // Get the reference for later.
                  window.chartObject = $("#chart-container").data("ejChart");
                  
                  chartRendered = true;
                } else {
                  // Then since the chart has already been rendered, we just need to enable the new data and re-render it.
                } // (chartRendered)
              } // if (currentEventData.dd !==undefined)
              break;

            default:
              throw "Invalid section " + section;
          }
        }
    });
        
    </script>
  </body>
</html>
