<!DOCTYPE HTML>
<html>
  <head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0,maximum-scale=1.0, user-scaleable=no" />
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  <meta name="applie-mobile-web-app-capable" content="yes" />
  <meta name="description" content="bwim" />

  <title>Manitoba BWIM Event Viewer</title>
  <link href="http://cdn.syncfusion.com/js/mobile/ej.mobile.all-latest.min.css" rel="stylesheet" />
  <script type="text/javascript" src="socket.io-1.1.0.js"></script>
  <script type="text/javascript" src="http://code.jquery.com/jquery-2.0.0.min.js"></script>
  <script type="text/javascript" src="syncfusion/assets/external/jquery.globalize.js"></script>
  <script type="text/javascript" src="http://borismoore.github.io/jsrender/jsrender.min.js"></script>
  <script type="text/javascript" src="http://cdn.syncfusion.com/js/mobile/ej.mobile.all-latest.min.js"></script>

  </head>
  <body>

  <!-- AppView declaration -->
  <div data-role="app$iew">Mobile JS Application
    <div><select id="year">
        <option value="2014">2014</option>
      </select>
      <select id="month">
        <option value="6">06 (JUN)</option>
        <option value="7">07 (JUL)</option>
        <option value="8">08 (AUG)</option>
        <option selected value="9">09 (SEP)</option>
      </select>
    </div>
    <div id="mobgrid"></div>
  </div>




    <script type="text/javascript">
    $(function() {


        // This one won't actually have the values that are required so much anymore

        var socket = io.connect("misc.mathewgrabau.ca:8888/");
        var firstTime = true;

        // This is the one getting bound to my events of the data now.
        var bridgeEvents = [];

        var requestId = 0;

        socket.on("news", function(data) {
            if (!firstTime) {
              return;
            }

            firstTime = false;

            // Initialize the grid now, start getting the data better

            var dataRequest = {
              sensorType: "bwimEvents",
              date: 20140901,
              id: requestId
            };

            requestId++;

            socket.emit("req", JSON.stringify(dataRequest));

        });

        $("#month").change(function() {

            console.log($(this).val());

            // TODO we need to get the values for the day in there as well.


            var month = parseInt($(this).val());

            // Then the parsing of the requested values must be sent out.
            var d = parseInt($("#year").val()) * 10000 + parseInt($("#month").val()) * 100 + 01;

            console.log(d);

            var request = {
              sensorType: "bwimEvents",
              date: d,
              id: requestId
              };

              requestId++;

            socket.emit("req", JSON.stringify(request));
            });

        var dataManager= null;
        var receivedData = [];

        var firstEventSelection = true;

        //var currrentEventData = null;
        window.currentEventData = null;

        socket.on("section_data", function(data) {

            // Get the data back from the parsing of the values that are attempting to be created.
            var received = JSON.parse(data);

            console.log(received);

            currentEventData = received;

            // Determine if the values exists yet.
            if (firstEventSelection) {
              firstEventSelection = false;

              $(".appview").append("<div id='section-selector'></div>");
              $("#section-selector").append("<label><input type='radio' />AA</label>");
              $("#section-selector").append("<label><input type='radio' />CC</label>");
              $("#section-selector").append("<label><input type='radio' />DD</label>");

              $("#section-selector").ejmGroupButton({
                  touchEnd: sectionGroupTouchEnd
                });
            }
        });

        function sectionGroupTouchEnd(args) {
          console.log(args.text);
          updateSectionChart(args.text);
        }

        socket.on("req_data", function(data) {
            var received = JSON.parse(data);

            // TODO implement the requesting queue already, so in otherwords add ot the data manager.

            // TODO we need to customize these implementations soon, allowing
            if (dataManager == null) {

              receivedData = received.events;
              dataManager = ej.DataManager(receivedData);

              // There are too many items (it only seems to show 14 of them)
              $("#mobgrid").ejmGrid({
                  dataSource: dataManager,
                  allowSelection: true,
                  allowColumnSelector: true,
                  allowPaging: true,
                  allowScrolling: true,
                  scrollSettings: {enableColumnScrolling: true}, 

                  actionComplete: gridActionComplete,

                  rowSelected: gridRowSelected,
                  columns: [
                    { field: "StartTime_DD", width: 200, headerText: "S/DD"},
                    { field: "EndTime_DD", width: 200 , headerText: "E/DD"},
                    { field: "StartTime_CC", width: 200, headerText: "S/CC" },
                    { field: "EndTime_CC", width: 200, headerText: "E/CC" },
                    { field: "StartTime_AA", width: 200, headerText: "S/AA" },
                    { field: "EndTime_AA", width: 200, headerText: "E/AA" }
                    ]
                    });
            } else {

              console.log(dataManager);


              // Apparently this is the most efficient way to do this.
              while (receivedData.length) {
                receivedData.pop();
              }


              // NOTE: I may need a specific value to insert properly.
              received.events.forEach(function(element, index) {
                  dataManager.insert(element);
                  });


              var grid = $("#mobgrid").data("ejmGrid");
              grid.refreshContent();
            }
      });

        // This is just checking for a first (loaded) event.
        var gridFirstEvent = true;

        function gridActionComplete() {
          console.log("gridActionComplete");
          console.log(arguments);

          if (gridFirstEvent) {
                        // Then install/generate the first.
          }
        }
            

        function gridRowSelected(e) {
          console.log(e);

          // Then we need to make sure that things are working out well for the appication
          // by closing/hiding the grid, and showing the rendering.
          // We need to emit a socket request, that will get the values of the sectional data.

          // Get the year and properly format that date.


          var MILLISECONDS_SIZE = 1000;
          var SECONDS_SIZE = 100;
          var SECONDS_SHIFT = MILLISECONDS_SIZE;
          var MINUTES_SIZE = 100;
          var MINUTES_SHIFT = SECONDS_SHIFT * SECONDS_SIZE;
          var HOURS_SHIFT = MINUTES_SHIFT * MINUTES_SIZE;
          var HOURS_SIZE = 100;
          var DAY_SHIFT = HOURS_SIZE * HOURS_SHIFT;
          var DAY_SIZE = 100;
          var MONTH_SHIFT = DAY_SHIFT * DAY_SIZE;
          var MONTH_SIZE = 100;
          var YEAR_SHIFT = MONTH_SHIFT * MONTH_SIZE;
          
          // Create the proper date now
          var year = parseInt($("#year").val()) * YEAR_SHIFT;

          var addYear = function(x) {
            return year + x;
          }

          var eventRequest = {
            id: requestId,
            sensorType: "eventdata",
            /*StartTime_AA: e.data.StartTime_AA,
            EndTime_AA: e.data.EndTime_AA,
            StartTime_CC: e.data.StartTime_CC,
            EndTime_CC: e.data.EndTime_CC,
            StartTime_DD: e.data.StartTime_DD,
            EndTime_DD: e.data.EndTime_DD
            */
            StartTime_AA: addYear(e.data.StartTime_AA),
            EndTime_AA: addYear(e.data.EndTime_AA),
            StartTime_CC: addYear(e.data.StartTime_CC),
            EndTime_CC: addYear(e.data.EndTime_CC),
            StartTime_DD: addYear(e.data.StartTime_DD),
            EndTime_DD: addYear(e.data.EndTime_DD)
          };

          socket.emit("req", JSON.stringify(eventRequest));

        }

        var chartReady = false;

        function ensureChartReady() {
          if (!chartReady) {
            $(".appview").append("<div id='chart-container'></div>");
            chartReady = true;
          }
        }

        function updateSectionChart(section) {
          switch (section) {
            case "AA":
              if (currentEventData.aa !== undefined) {
                ensureChartReady();

                // THen prepare the data for the renderings now. 
                // There should be nothing to fear here (it should work perfectly, right?)

                // TOOD probably need to implement some proper mapping events there

                var seriesG25 = [];

                currentEventData.aa.forEach(function(element, index, array) {
                    seriesG25.push({
                        value: element.G25,
                        date: element.ms
                        });
                });

              }
              break;

            case "CC":
              if (currentEventData.cc !== undefined) {
                ensureChartReady();
              }
              break;

            case "DD":

              if (currentEventData.dd !== undefined) {
                ensureChartReady();

                var seriesG1 = [];

                currentEventData.dd.forEach(function(element, index, array) {
                    seriesG1.push({
                        value: element.G1,
                        ms: element.ms
                        });
                });

                currentChartSource = seriesG1;

                var zoomingOptions = {
                  enable: true,
                  enableMouseWheel: true
                };

                var commonSeriesOptions = {
tooltip: {
           visible: true
         }
                };

                console.log(seriesG1);
                $("#chart-container").ejChart({
commonSeriesOptions: {
  tooltip: {visible: true}
},
                    zooming: zoomingOptions,
series: [{
    type: "line",
    xName: "ms",
    yName: "value",
    dataSource: seriesG1,
  }
  ]
              });

                // TODO figure out why the zooming doesn't want to be enabled.

              }
              break;

            default:
              throw "Invalid section " + section;
          }
        }
    });
        
    </script>
  </body>
</html>
